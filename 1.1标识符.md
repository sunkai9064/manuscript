### 标识符名称

在ECMAScript规范中标识符名称定义为：根据 Unicode 标准附件 #31，“标识符和模式语法”中给出的默认标识符语法进行解释的标记，并进行了一些细微调整，语法上将标识符(Identifier)定义为不是保留字的标识符名称。除了与变量相关、还与子程序、形式参数及其他结构相关。最终声明的标识符都是对其求字符串值(StringVlaue)的结果。

标识符名称与名字一词经常会互换使用，但二者还是有区别的，所有的标识符都是名字，但不是所有的名字都是标识符。例如x.y是一个名字，但是标识符是x和y(也被称为限定访问标识符)，这种这种复合名字称为限定名字（qualified name）。

### 关键字和保留字

保留字是不能用作标识符的标识符名称。，在考虑标识符的合法性之前，必须要刨除语言自身的保留字。规范中描述了四组保留字：keywords, future reserved words, null literals and boolean literals。目前已知的保留字如下：

    ReservedWord::one of（one of 是EBNF种的表示法）
    
        await break case catch class const continue debugger default delete do else enum export extends false finally for function if import ininstanceof new null return super switch this throw true try type of var void while with yield


关键字是在 JavaScript 中具有特殊含义的标记：break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void,while和with。

未来的保留字是在 ECMAScript 的未来修订版中可能成为关键字的标记：class、const、enum、export、extends、import和super。一些未来的保留字仅适用于严格模式：implements, interface, let, package, private, protected, public, static, 和yield。

>注意：在语法解析阶段会将词法声明记录中出现let视为早期错误(Early Errors)

全局对象的NaN、Infinity、 和undefined属性在 ES5 中是不可变的或只读的属性。因此，即使var NaN = 42;在全局范围内不会抛出错误，它实际上也不会执行任何操作。然而在程序的其它位置却会带来意想不到的错误，因此始终建议使用它们的替代版本：

```js
// In the global scope:
var NaN = 42;
console.log(NaN); // NaN

// …but elsewhere:
(function() {
	var NaN = 42;
	console.log(NaN); // 42
}());
```

在严格模式下，eval和也arguments不允许作为变量名。（在这种情况下，它们的作用就像关键字一样。）

旧的 ES3 规范定义了一些 ES5 中不再保留的保留字：int, byte, char, goto, long, final, float, short, double, native, throws, boolean, abstract, volatile,transient和synchronized。为了获得最佳的向后兼容性，避免这些可能是一个正确的决定。

最后需要注意，语法中的关键字匹配特定SourceCharacter元素的文本序列。ES2015明确规范关键字中的码点不能用\UnicodeScapeSequence表示：

```js
//supported in old ES5 engines:
var v\u0061r;

\u0069\u0066(true){}
//Uncaught SyntaxError: Keyword must not contain escaped characters
```

### 有效标识符

在规范中一共规范了五类标识符名称:

- 始终允许用作标识符而不是关键字的变量，例如Math，window，toString和_；
- 永远不允许用作标识符的标识符，即上述列出的保留字，但wait和yield除外；
- 在上下文中被允许作为标识符的那些，即await和yield；
- 在严格模式下，那些在上下文中不允许作为标识符的标识符：let, static, implements, interface, package, private, protected,和public
- 那些始终被允许作为标识符的变量，也可以在某些语法产生式中作为关键字出现在不允许使用标识符的地方：as，async，from，get，meta，of，set和target。

```js
let  Math = 1   //is ok

let const = 1   //Unexpected token 'const'

function a(){
    var await =1    //is ok
}

async function a(){
    var await =1    //Unexpected reserved word， 同样不可出现在module context中
}

var let = 1         //is ok


"use strict";       //VM550:2 Uncaught SyntaxError: Unexpected strict mode reserved word
var let = 1

let async = 1
```

术语“条件关键字（conditional keyword）”或“上下文关键字（contextual keyword）”有时用于表示属于最后三个类别的关键字，因此可以在某些上下文中用作标识符，而在其他上下文中用作关键字。

### 可接受的 Unicode 符号

在确定了标识符的合法范围后，下一步就是了解标识符的编码规范了。在ES2015中，标识符必须以$、_或具有Unicode派生核心属性ID_Start的任何符号开头。

标识符的其余部分可以包含$、U+200C零宽度非连接符、U+200D 零宽度连接符或具有 Unicode派生核心属性ID_Continue的任何符号。 

这与基于 Unicode 类别的ES5 标识符名称的定义不同。因此，ES5 标识符中不允许的一些 Unicode 符号现在可以在 ES2015 标识符中使用，反之亦然。

```js
// Valid in ES5 & Unicode v5.1.0+, but invalid in ES2015:
var ⸯ; // U+2E2F VERTICAL TILDE
var \u2E2F; // U+2E2F VERTICAL TILDE

```

此外在ES5中也是支持Unicode代码转义序列的：

```js
var \u0061;
```

ES2015通过Unicode代码点转义语法扩展了该语法，其规定IdentifierName中允许使用Unicode转义序列，在该序列中，它们向IdentifierName贡献单个Unicode码点。 该码点由UnicodeEscapeSequence的CodePoint表示。 UnicodeEscapeSequence之前的\以及u和{}代码单元（如果出现）不会为IdentifierName提供码点。并且支持了星体符号：

```js
var \u{61};

// Invalid in ES5, but valid in ES2015:
var 𐊧; // U+102A7 CARIAN LETTER A2
var \u{102A7}; // U+102A7 CARIAN LETTER A2

// Invalid in ES5 and ES2015:
var \uD800\uDEA7; // U+102A7 represented as a surrogate pair
```

### 对象中的有效标识符

对于对象中的合法标识符就要宽松多了，它可以是任何的标识符名称，字符串字面量或数字字面量。这意味着下面的写法都是合法的：

```js
let \u0069 = {
    \u0066: 2
}

i.f //2

let obj = {
    const: 1,
    1.23e34: 2
}
//{const: 1, 1.23e+34: 2}
```

对于数字字面量会求其StringVlaue，所以可以用下面的任意一种方式获取其值

```js
//The following are all ok
obj[1.23e34]
obj[1.23e+34]
obj['1.23e+34']
obj[12.3e33]

//not ok
obj['1.23e34']      //undefined
obj['12.3e33']      //undefined
```

但是只有当是标识符名称或数字字面量的时候才可以省略引号：

```js
let obj = {
    a d: 1,     //case1
    2-3: 2,     //case2
}

let obj1 = {
    0: 0,
    "a d": 1,
    "2-3": 2,
}

obj[0]          //0
obj["a d"]      //1
obj["2-3"]      //2
```

对于case1的情况“a d”明显不是一个合法的标识符，case2中“-”被解释为了减负符号可以通过添加引号或者使其变为计算属性(但这往往不是原始的意图)使其合法化。对象的取值可以使用.和[]语法，[]适用于任何的属性名称，而.语法只适用于合法的标识符名称。
