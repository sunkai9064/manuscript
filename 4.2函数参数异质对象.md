## arguments对象

根据函数定义的特性，arguments对象可以是一个普通对象，也可以是一个异质对象（Exotic Objects）。这两种对象都具有一个[[ParameterMap]]内部槽，普通对象的值为undefined,异质对象则是把所有参数在这里做了一次映射。arguments的设计可以说是对函数造成了严重的破坏。由于其并不是一个保留字，作为一个普通的标识符也就失去了保护，导致了在参数界面上或函数体中的重复声明会覆盖arguments对象,例如：

```js
function f1(arguments){
    console.log(arguments)
}

function f2(arg){
    let arguments
    console.log(arguments)
}

f1(1)
f2(2)
```

这就导致了arguments对象形同虚设，在es6以前将无法准确获取一个匿名函数实参的个数：

```js
(function(arguments){
    //length?
})(1, 2, 3)

(function(...arguments){
    console.log(arguments.length)
})(1, 2, 3)
```

在严格模式下会修复这一问题，其将创建一个不可观察的不可变的绑定（因为早期错误检查会提早报告错误）,然而其报告的异常却让这一行为变得扑朔迷离。

```js
function f(){
    "use strict";
    arguments = 1
}
f()     //Uncaught SyntaxError: Unexpected eval or arguments in strict mode
```

然而arguments的破坏性并未止于此，在箭头函数和非简单参数出现之前，非严格模式的函数中创建的是一个异质对象。这个arguments与参数界面的参数是一一映射(mapping)的，修改arguments中的元素也会导致参数界面的值发生改变，反之亦然。可这种映射关系却是不牢靠的，语言中存在多种方法切断这种关系，下面通过属性的删除和属性描述符的定义来说明这一特性：

```js
function f3(p1, p2){
    delete arguments[0]     //通过删除属性并重新定义切断mapping
    arguments[0] = 2
    arguments[1] = 3
    console.log(p1, p2)     //1, 3
    console.log(arguments)  //Arguments(2) [2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}

f3(1, 2)

function f4(p1, p2){
    Object.defineProperty(arguments, '0', {
        get(){
                return 123      //属性描述符切断mapping
        }
    })
    console.log(p1, p2)         //1, 2
    console.log(arguments[0])   //123
}
f4(1, 2)
```

### argumtengs异质对象的行为

1. 覆写了[[GetOwnProperty]] 
    - 尝试在args上寻找key，如果没找到返回undefined
    - 找到key所对应的属性描述符后尝试将[[ParameterMap]]中对应的值更新到[[value]]
2. 覆写了[[DefineOwnProperty]]，这里补充一个上述切断mapping关系的方式
3. 覆写了[[Delete]]、 [[Get]] 和 [[Set]]使其在异质函数的情况下对[[ParameterMap]]进行处理


```js
function f(a) {
    //当描述符不具有值且可写属性为false,将使用 Get(map, P)的值并且该属性不再是受关联属性
    Object.defineProperty(arguments, '0', {writable:false})
    a= 2
    console.log(a) //2
    console.log(arguments); //Arguments [1, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}

f(1)
```

CreateMappedArgumentsObject包含了argumens异质对象创建的完整过程，其中对于参数名称的遍历是倒序的，也就是说对于同名参数这个映射关系只存在于最后一个：

```js
function f(p1, p1){
    p1 = 5
    console.log(arguments) 
}

f(1, 2)
```

