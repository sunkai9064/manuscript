### 函数声明实例化

在javascript引擎实现中分为内置函数和ECMAScript代码定义的一般函数。如无特殊说明，下文提到的函数都指由ECMAScript代码定义的函数，而非内置函数。

函数声明实例化过程依靠着为其创建执行上下文的函数对象和参数列表。实例化过程要完成的事情包括，参数的注册与初始化、函数体内的声明与初始化、参数对象的绑定。

在这一过程中总是会先计算出参数名称列表（这之中又包括重复名标志和非简单参数标志）^1^和由ECMAScriptCode代码所声明的名字列表及其解析节点（用于参与作用域计算）。

在名字的绑定过程中，首先会遍历varDeclarations中的函数类(这里的类指的是类别：例如 FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, 或 AsyncGeneratorDeclaration.)声明，并且这个过程对于列表的顺序是翻转的(从最后一个开始遍历)，如果在FunctionNames中并未有此标识符，则将其加入到函数初始化列表(functionsToInitialize)等待初始化。

关于是否需要创建一个异质参数对象arguments我们已经在4.2函数参数异质对象中介绍，这里只是作为初始化过程中的一个部分进行补充。在参数注册的过程中，对于没有声明的标识符会创建一个可变绑定，然而初始化的时机却不相同。当参数列表中存在重复的标识符，意味着只需要对与初始化的名字进行迭代赋值。另一种情况则需要传递一个环境记录进行初始化。

> 注1：举例来说当出现重复名称预示着应使用PutValue 操作来分配初始化值，非严格函数的形式参数列表就是这种情况。在这种情况下，形式参数绑定会被预先初始化，以便处理多个同名参数的可能性。简单参数的判定则直接影响是否要创建一个具有mapping关系的参数对象。

对于var声明的名字只有不在参数列表中才会进行初始化，否则会跳过这一名字。需要注意的是，在这个例子中打印不可在var之后，虽然不会进行重复声明，但赋值总是执行的^2^。

```js
function f(p){
	console.log(p)	//1,没有重新声明
	var p = 2
}
f(1)
```

> 注2：函数内赋值失败的情况请参阅“函数名”小节

当处于严格模式或无表达式参数时，只需为参数创建一个环境记录，因为严格模式代码中调用 eval 不能创建在 eval 之外可见的新绑定，否则需要创建一个不同的环境用于保存eval创建的新绑定，并且这个用于保存eval创建绑定的新环境将作为当前上下文的外部环境（outerEnv）。为了验证这种情况，可以在函数参数中添加参数b和参数c（使用eval创建）,并在函数体内分别创建同名变量以达到测试的目的:

```js
function f1(
    a = eval("var c = 3"),
    b = 2,
)
{
	console.log(c)	//3
    let b = 1		//标识符重复声明
}

f1()
```

```js
function f2(
    a = eval("var c = 3"),
    b = 2,
)
{
	let c = 1
}

f2()
```



词法声明的过程则与var声明和函数声明不同：一是名字的唯一性^2^；二是其在这个阶段只进行实例化而不进行初始化。

> 注2：不能与function、generator、formal parameter，var name中的名字相同。

函数的初始化是最后进行的，这也是函数提升秘密的由来。

非严格函数对顶级词法声明使用单独的环境记录，以便直接 eval 可以确定 eval 代码中所引入的任何 var 声明是否与预先存在的顶级词法作用域声明冲突。 这对于严格函数来说不是必需的，因为严格的直接eval总是将所有声明放入新的环境记录中。

```js
function f(){
	// "use strict" 严格模式下eval中所声明的变量不会和当前词法环境冲突
    eval("var a = 1")
    let a = 1
}
f()
```

