# ES6对象操作的行为

## 替换而不是赋值

对象展开运算符的重复键依赖其出现的顺序，当出现相同的键会覆盖掉前者。这里的关键是如何理解覆盖一词。了解这个过程是极为必要的，尽管大多数开发者从没想过这个问题。当我们把它定义为重新赋值，那么就会触发它的setter,这会引起一些副作用甚至影响本应该有的语义:

```js
let record = { x: 1 };
let obj = { set x(p) { throw new Error(); }, ...record }; // 这里不会触发任何异常
obj.x; // 1
```

此外getter在数据源上执行，而不是将描述符复制到新对象，很自然这与Object.assign的行为一致。

同样的，当我们想要一个使用 [[DefineOwnProperty]]/[[GetOwnProperty]] 而不是 [[Set]]/[[Get]] 的 Object.assign 替代版本，以避免副作用和复制 setters/getters，可以使用Object.getOwnPropertyDescriptors，从而简化对象间的复制行为。

## 对象的可迭代转换

出于迭代或序列化的目的，从对象获取键/值对数组（规范中称为“entries”）也很有用。 随着接受可迭代条目的 Map 构造函数及其关联的条目迭代器（WeakMap 也在其构造函数中接受可迭代条目）的出现，想要通过将entries数组传递到新Map中来快速将普通对象转换为Map变得非常有吸引力。

## 对象的非规范构造方式

Object.fromEntries方法并不是一种规范的构造对象的方式。对象实际上与其他容器不同，具有访问器和原型等，并且它的构造函数不能以这种方式接受条目列表，例如，Map就是这样做的。其使用 ToPropertyKey 抽象操作将对列表中的第一个条目强制为属性键。这与创建或分配对象属性的其他方法是一致的。然而他并不与Object.entries完全对称，由于Object.entries并不报告使用Symbol作为键的属性(这是由于[[OwnPropertyKeys]]()语义造成的),导致了二者行为上的偏差：

```js
let prop = Symbol();
let obj = Object.fromEntries([[prop, 0]]);
console.log(obj[prop]); //0

Object.entries(obj) //[]
```

fromEntries 期望其参数生成的键值对是带有键“0”和“1”的对象，分别对应键和值，而不是第一个和第二个项分别对应键和值的可迭代对象(虽然字符串对应的包装类也具有0,1的属性，但强制迭代器产生的值是对象，保持和Map构造函数具有相同的行为)。

```js
let obj = Object.fromEntries([{0:1, 1: 2}]);
```

如此处理是为了与 Map 构造函数保持一致，后者以完全相同的方式获取整体列表（除了它不使用 ToPropertyKey 强制键）。

通常，该对象被实现为二元数组，除非重写了Array.prototype[@@iterator]，否则这种行为是等效的。

该方法要求其第一个参数是可迭代的，而不是“类数组”（具有数字值长度属性和可能的数字键属性的对象）。 这意味着传递一个参数对象将导致此方法抛出（除非定义Object.prototype[@@iterator]）。 这与 Array.from 不一致，Array.from 接受“类数组”。然而，Array.from 的行为是专门用于类数组的转换，不需要在其他地方复刻。

```js
function f1(p1, p2){
    console.log(Object.fromEntries(arguments))
}

f1(1, 2)

function f2(...p){
    console.log(Object.fromEntries([p]))
}

f2(1, 2)
```

这与 Map 构造函数不同，但类似于 Array.from 和迭代协议的大多数其他用途。 Map 构造函数还用于构造新的空 Map，但这不是构造新空对象的首选方式。

在使用 ToPropertyKey 强制键之前从条目记录中获取值。 这很重要，因为这两个步骤都是可见的。这有点随意，但与常规赋值一致： ({}[{ toString(){ console.log(2); return ''; } }] = console.log(1)) 打印 1, 2。

该方法不允许指定结果对象的原型。但是， Object.assign(Object.create(proto), Object.fromEntries(entries)) 可用于相同的效果（[[Set]] 与 [[DefineOwnProperty]] 差异）。

该方法不允许创建非数据属性，例如从键属性描述符对列表中创建。但是，给定这样的列表，可以使用 Object.defineProperties({}, Object.fromEntries(list)) 达到相同的效果。

该方法不允许在现有对象上安装属性。但是，Object.assign(obj, Object.fromEntries(entries)) 可用于相同的效果（[[Set]] 与 [[DefineOwnProperty]] 差异）。

该方法使用 DefineOwnProperty 语义在新创建的对象上安装属性。这与 Object.create 和 Array.from 一致，并避免触发 Object.prototype 上的 setter。对于重复键的处理默认遵循了一般处理方式(后者覆盖前者)

```js
let obj = Object.fromEntries([{0:1, 1: 2, 0:3}]);   //{3: 2}
```

Array.from 用于将任意可迭代对象转换为数组，mapping在这个过程中不可缺少，然而该方法只用于定向的转换，一般不需要转换的过程。

## 属性的检索与复制

getOwnPropertyDescriptors提供了检索对象自身所有的描述符能力，可以简化对象之间的的复制行为，假设您想要使用[[DefineOwnProperty]]/[[GetOwnProperty]]而不是[[Set]]/[[Get]]的Object.assign版本，以避免副作用和复制setter/getter，但仍使用可枚举性作为区分因素，那么这个方法可以很好的帮助到你。

## 更安全的属性检查机制

在ES6之前，Object.prototype.hasOwnProperty是检查自身属性的常用手段，但无法保证这个方法是可用或是未被修改的，这样的代码可能埋下隐患：

```js

//不具有hasOwnProperty方法
Object.create(null).hasOwnProperty("name")

//屏蔽原型方法
let obj= {
    get hasOwnProperty(){
        throw '覆盖了原型方法'
    }
}
obj.hasOwnProperty('name')
```

正因如此，一些代码检查工具也提供了在数据上直接调用原型上方法的检查，例如eslint的no-prototype-builtins规则会希望你使用下面的方式：

```js
Object.prototype.hasOwnProperty.call(object, 'name')
```

至此，不得不考量的是原型上的一切方法都将不再适用，此外Reflect上的静态方法与Proxy traps是一一对应的，Proxy 上已经有一个方法可以捕获 hasOwnProperty (通过getOwnPropertyDescriptor)。权衡之下，为Object添加一个静态的hasOwnProperty是能解决上述所有问题的有效方法。

