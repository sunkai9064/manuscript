## 脚本

当引擎收到已经加载完毕的脚本（script）会首先会进行脚本解析（规范中封装在了ParseScript 抽象方法中）。它会使用goalSymbol（ECMAScript语法之一中的非终结符）作为目标符号解析代码源文本（sourceText），并分析结果中是否存在任何早期错误（early error）的情况。规范中并没有要求检测早期错误的时机， 解析和早期错误检测可以以实现定义（implementation-defined）的方式交织在一起。并且规范也没有要求当出现错误的时候应该返回第一个错误还是全部错误，已知的现有实现中全部采用了前一种方式。并且在极端情况下，当脚本同时检测出语法错误和早期错误，这两种检测机制也是可以同时进行的，此时可能返回早期错误，或者同时报告这两种错误都是符合规范的,大多数实现都采用了前一种方式：

```js
function f(){
    var a = 1
    let a = 2
    if{}
}
//Uncaught SyntaxError: Identifier 'a' has already been declared
//在解析早期错误后并不会报告语法错误
```

>注：ECMAScript的早期错误一种静态语义检查，是对源代码执行的一种分析，用于识别任何潜在的语义错误或违反语言规则的行为。这种分析确保代码符合语言的语法和基本语义。

### 脚本记录

脚本记录用于记录正在评估的脚本的信息，具有以下字段：

- [[Realm]]：存储当前的域，如果不存在则为undefined
- [[ECMAScriptCode]]：以 Script 作为目标符号记录解析脚本的源文本的结果
- [[LoadedModules]]：一个包涵[[Specifier]]和[[Module]]字段的记录列表。[[Specifier]]是唯一的说明符名字，[[Module]]是模块记录。
- [[HostDefined]]：为需要将附加信息与脚本关联的主机环境保留的字段，默认值是空

### 解析脚本

解析脚本的过程已经在本节开头描述过了，这个过程就是要将解析的结果存装填脚本记录中：

{ [[Realm]]: realm, [[ECMAScriptCode]]: script, [[LoadedModules]]: « », [[HostDefined]]: hostDefined }

至此就完成了脚本解析的全过程，下一步就是脚本的评估。

### 脚本评估

脚本评估的过程要相对复杂，该过程接收参数脚本记录(即脚本解析过程中装填好的记录)，在这一过程主要确定全局环境，并创建一个新的执行上下文scriptContext^1^以供脚本的解析执行，并在结束后恢复到原上下文。

其中全局环境就是[[Realm]].[[GlobalEnv]]，并将scriptContext的VariableEnvironment和LexicalEnvironment设置为全局环境，PrivateEnvironment设置为null。此时暂停当前正在运行的执行上下文，并将scriptContext推入执行上下文堆栈作为当前的执行上下文。并返回由全局声明初始化得到的结果，在没有异常的情况下该结果为：

{ [[Type]]: normal, [[Value]]: undefined, [[Target]]: empty }

至此脚本评估过程结束。 

>注1：读者在这里不需要了解执行上下文的创建过程，10.3章节会详细讨论。

### 受限全局属性

在JS的早期设计中将一些本该设为保留字的名字注册在了全局属性上，它们都具有不可配置这一共性，这些属性被称为受限全局属性（RestrictedGlobalPropert），包括：
NaN，undefined，Infinity,这一类属性的值是无法修改的也是不应该修改的，但由于历史原因在使用var重新声明或进行值的修改时不会提示错误。尽管在严格模式中修正了这一错误行为，但这却是在语义层面上抛出的错误：

```js
var NaN = 1      //没有错误

"use strict";
//console.log(1)
var NaN = 1
//Uncaught TypeError: Cannot assign to read only property 'Infinity' of object '#<Window>'
```

在ES6引入lexical声明（let/const）后，将检测这一类特殊的名字：

```js
//console.log(1)
let NaN = 1
//Uncaught SyntaxError: Identifier 'NaN' has already been declared
```

注释掉的console是我们将要探讨的第二个问题，聪明的读者可能已经从两个错误提示中联想到错误的检查时机并不相同。当我们使用var声明RestrictedGlobalProperty的报错是在初始器赋值的时候报告的，也就是运行期，1会被正常打印出来。而let声明则将错误的检测时机提升到了语法分析期间，更早的识别出此类错误，所以不会打印1。

由于历史原因，这个设计问题将一直延续下去，幸好的是我们可以使用全局对象构造器属性作为替代版本Number.NaN，Number.POSITIVE_INFINITY，Number.NEGATIVE_INFINITY。仅仅这样是不够的，我们始终应该使用lexical声明替代var声明从而让解析器更好的发现这些错误。

### 全局声明初始化

现在就让我们解开声明注册的神秘面纱，全局声明初始化（GlobalDeclarationInstantiation）是对全局声明标识符的注册过程。对于不同的声明会进行相应的处理：

- 首先会遍历脚本中的词法名字(lexNames)，并将下面三种情况视为语法错误
    1. var声明中有相同的名字
    2. lex声明中有相同的名字
    3. 和受限全局属性同名
- 然后会遍历脚本中的变量名字(varNames)，并在lexNames中有同名属性时提示语法错误

至此如果没有引发任何错误，便将脚本需要注册的名字检查完毕。下一步便是要根据这些名字所在的节点类型去进行初始化。ECMAScript中会分别处理var声明和lex声明。就像读者所知道的那样，var声明得到名字会进行提升，所以首先处理这部分：

- 将所有的var声明(varDeclarations)分为两部分：
    1. 声明function名字
    2. 声明var名字

首先，会按var声明的名字列表相反的顺序进行遍历，将函数类（FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, AsyncGeneratorDeclaration）声明记录到一个名字为declaredFunctionNames的列表中，如果包含多个同名函数则使用最后一个。然后检测其是否可注册在全局对象^1^上，不可以则为类型错误。否则将其加入到带初始化函数列表的头部(因为是反向遍历)。var声明包括VariableDeclaration, ForBinding, BindingIdentifier，和函数类的声明稍有不同，由于其不需要初始化(初始化的值为undefined)，所以是正向遍历列表，并注册到declaredVarNames中。

```js
//词法声明检查早于函数
function undefined(){
    
}
let Infinity = 1
//Uncaught SyntaxError: Identifier 'Infinity' has already been declared
```

```js
//函数早于var
var Infinity = 1
function undefined(){
    
}
//Uncaught SyntaxError: Identifier 'undefined' has already been declared
```

>注1：这里讨论的全局对象都为普通全局对象。

如果在非严格模式下，用一个包含F的绑定标识符替换该函数声明F，不会引发任何错误。并且词法环境中没有相同的标识符名称，则尝试将F注册到全局。

```js
let f;
{
    function f(){}
}

window.f    //
```

只有当F的var绑定既不是VarDeclaredName也不是另一个FunctionDeclaration的名称时，它才会在这里实例化。

```js
console.log(f)          //undefined
var f;
{
    function f(){}
}


console.log(f)          //f(){}
{
    function f(){}
}
```

下一步就是词法声明的注册，注意，这一步中要区分let(可变绑定)和const(不可变绑定)。然后遍历functionsToInitialize列表的每一个节点以初始化函数并绑定到全局对象上，最后创建全局的var的绑定。